# LAB2 REPORT

## 总述

本次实验包括三个练习，实现了物理内存分配，完成二级页表的建立和管理。

## 练习

### 练习一/物理内存分配

#### 任务实现

练习一是将默认的内存分配算法改为first fit分配算法。

first fit分配算法的工作原理即将空闲内存块组织成按起始地址排序的链表，每次选择内存中第一段可以分配的空闲内存进行分配。原理非常简单，接下来略微说明实现细节。

所有物理页的分配情况被Page*数组连续存储在内存中。一段连续空闲空间中的第一个页被选中作为代表，其中存储这一段连续空间的信息，被插入链表当中。由于是连续分配，页的排列顺序实际上和物理页是完全一致的。因此，要按物理页的起始地址排序，实际上按照Page结构的位置排序也是等价的。

原本给出的框架里已经给了基本的alloc, free，只是没有按照地址顺序排列，只需要加上在插入页时寻找正确位置插入链表的功能即可。

#### 题目回答

+ 你的first fit算法是否有进一步的改进空间

改进空间:first fit需要每次都从最低地址开始查找，如果产生了很多外碎片，内存被打断产生较多小空间内存块，此时算法的效率会比较低。为了加速查找，可以考虑使用多个链表：根据剩余空间的大小区间不同，将区间插入到不同的链表当中。这样，要分配内存时，也可以根据需要分配的内存大小，直接去相应的链表查找，而无需查找那些一定比需求空间要小的空闲区域。按照这种方式，效率应该会有一定提高。

#### 对答案

原本的代码有一处该修改的没有修改，但还是过了检测样例，经过对答案才发现了错误。在进行alloc时，新的缩减了的空闲页面应该保持在原地，而原本框架里的代码把新页面项放在了链表头。初看时，由于误以为是直接修改了链表里元素，没有注意到有重新插入的操作。对完答案后已修改。

#### 知识点分析

实验中使用到了连续内存空间分配算法，但只是最简单的first fit算法，其余课程中所述的实用算法都没有涉及。

### 练习二/二级页表查找

#### 题目回答

由于不说明二级页表在ucore中实现的原理，很难描述实验的实现过程，故先回答提出的问题：

+ 请描述页目录项（Page Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

> 页目录项内容 = (页表起始物理地址 &0x0FFF) | AVAIL | G | PS | 0 | A | PCD | PWT | U | W | P
> 页表项内容 = (pa & ~0x0FFF) | AVAIL | G | 0 | D | A | PCD | PWT | U | W | P

包含了页表起始地址的前20位。以及控制位：

+ P，表示页表中是否存在该项；
+ W，表示是否允许写入；
+ U，表示用户态下是否允许读取；
+ PWT，表示是否使用Write-through，为0的话使用Write-back策略。
+ PCD，表示是否禁用cache.
+ A，访问位，表示该页是否被访问。
+ D，表示该页是否已被修改，由处理器硬件设置。
+ PS，设为1时page size增大为4MB。
+ G，全局位，若设为1该页将被保留在高速缓存中。
+ AVAIL，留给操作系统使用的保留位。

其中有一些是给硬件自行使用的，但也有一些可以供操作系统使用。例如，根据检查访问位A的设置，可以判断页的使用频率，从而用于页置换策略。再如AVAIL，可以用于操作系统设置标记等，进行一些额外的控制。

+ 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

硬件需要根据中断向量进入异常处理过程。其基本操作和lab1中所述的异常处理相同，但是也有页访问异常专用的处理步骤。

具体而言，即将当前访问导致错误的虚拟地址存入cr2寄存器中，并且将发生异常的原因存入error code之中（末尾3位，分别表示访问权限异常，写入异常，页缺失），以便异常处理过程来对症下药进行补救。

#### 任务实现

页表项的查找分成三步:

+ 从页目录项起始地址开始，查找到页目录项；
+ 页目录项中，若相应的二级页表不存在，则（根据输入参数决定）分配一个新页用于存储该页表；
+ 在二级页表中，查找出对应的页表项。

这里的查找都非常简单。因为页目录项和页表项均为32位数组，查找也就是取数组中的元素。值得注意的是表项中存的是线性地址，要使用时还需要使用KADDR函数把从表中读出的地址进行一下地址转换。

最后，对于分配的用于储存页表的新页，需要进行memset将其区域全部置0，防止出现错误查询，同时设置页权限为完全允许访问。

#### 对答案

由于这里功能几乎全由框架提供的各种API实现，实现的结果与答案基本相同。答案更喜欢使用数组，而我比较偏好使用指针，但这似乎并不是什么根本差异。

#### 知识点分析

使用到了二级页表的知识，包括页目录项的组成、页表项的组成、页表在内存中的存储和动态建立、虚拟地址，线性地址，物理地址的转换等等。在报告题目中还涉及到了缺页中断的硬件处理过程。

### 练习三/移出页面

#### 实现细节

这里移除页面并不是直接移除物理页面，考虑到有可能一个物理页面被多处引用，这里只是减小页面计数(page\_ref\_dec())，计数到达0时才真正释放页面内存(free\_page())。

此外，还需要清空该页表项的标志位，调用api在TLB中去除对应的项(tlb\_invalidate)。

#### 题目回答

+ 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

虚拟地址经过页目录项和页表项的转换，最终归于物理地址，而pages数组的安排和物理地址是相对应的。

在ucore代码中，页表项到Page的转换由pte2page函数实现。实际上，也即先将pte中的前20位作为物理地址提出，这20位即是物理页号，同时也是其在pages数组中的索引号。这样，便可以查询到对应的Page结构体。

+ 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？

这样做好像没有任何意义……但是如果一定要做，那么在给缺失的页分配页面时不能用连续空间内存分配算法，而要按照被访问的虚拟地址直接找到对应的物理地址，把那一片内存做为当前的页面使用，如果该内存区域存储了属于其他进程的数据，则需要将其换出。

#### 对答案

~~和答案相比，在移除页面后，答案直接将该页表项的标志位设置成了全0，而我是只将PTE\_P这一位表示存在与否的标志位设成了0.似乎这一点不是非常重要，因为判断该页表项是否存在一般都是根据PTE\_P一位进行判断，故只设这一位和全部设为0是等价的。而载入新页时整个项都会被修改，旧项全都会被覆盖，故似乎两者都是可行的。~~

edit: 在写lab3时发现了此处并不正确，因为页换出时需要考虑到页表项究竟是全空还是仅PTE\_P一位为空。所以此处已经修正，和答案一致了。

#### 知识点分析

这里除了练习二中已涉及的分页模块的基本功能知识之外，还涉及了页表项移除的流程。

需要学生自己实现的功能非常简单，不过实际上这里实现的功能从分配新页、设置对应、更改对应、释放页面一应俱全，只做需要做的部分虽然很轻松，不过还是需要看其他部分的实现比较妥当。