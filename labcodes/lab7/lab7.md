# LAB7 REPORT

## 综述

本lab实现了操作系统的同步互斥功能，包括其设计、实现。在底层，通过信号量、基于管程的条件变量两种方式解决了哲学家就餐问题。本次实验对之前代码的改动不大，只是新增了同步相关的功能和库，真正在内核中用到信号量的只有复制内存管理信息mm时一处。不过，到了lab8中，文件系统将大量使用信号量来进行互斥锁操作。


## 练习

### 练习一/内核级信号量

#### 架构分析

信号量的定义如下：

```
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```

也即，信号量与当前的值以及其控制的等待进程队列共同组成。其基本思想是简单的：

+ 当一个进程想要减小信号量时:
    + 首先判断其值是否大于0（一般意味着是否还有资源可以使用），若大于0则将值减一，成功返回；
    + 否则，当前进程需等到信号量大于0才能继续运行，此时当前进程进入等待状态，加入该信号量的等待队列中，进行调度；
    + 调度结束后（对当前进程来说，意味着自己等待状态解除，已经可以使用资源），将自己从信号量等待队列中删除，操作完成。
+ 当一个进程想要增大信号量时：
    + 若信号量的等待队列不为空，表示正有队列在等待信号量，不调整信号量的值而是激活队列中的第一个进程；
    + 否则，则普通地将信号量值加一。

需要注意的是，为了避免进程间冲突问题，对于信号量的值、等待队列的操作都必须暂时关闭中断进行，防止中途被中断切出、被调度而产生问题。

接下来再看哲学家就餐问题用信号量的解决办法：哲学家用餐实际上包括两个基本操作：拿起叉子、放下叉子，即占用和释放资源的两个步骤。此问题用了n+1个信号量，其中n为用餐人数，这n个信号量用于这n个进程内的阻塞操作。另一个信号量为互斥锁，用于记录临界区，保证所有进程中同时只有一个在访问这些信号量。

+ 占用时，首先进入临界区，让其他进程不能进行操作；然后开始正式获取资源，将自己设置为HUNGRY状态，表示自己在等待资源；接着试着直接获取两只叉子（若左右两人均为在用餐，则自己可以用餐）。但若获取不到，则退出临界区，对自己对应的信号量进行down操作，即进入阻塞状态，等待其他进程在释放完后帮自己分配叉子。
+ 释放时，同样进入临界区。将自己的状态置为空闲态(THINKING)，然后分别尝试自己左侧、右侧的人能否用餐（因为自己释放资源只影响这两人）。如果某一人能用餐，则让其进入EATING状态，并对其相应信号量执行up，即唤醒该进程。该进程此时已经退出了临界区，可以正常运行下去。查看了左右人之后，自己退出临界区，结束运行。

这样即完成了哲学家用餐问题的解决。

#### 问题回答

请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

由于信号量的实现需要执行开关中断这类内核态操作，用户态要使用时，必须通过系统调用调用内核提供的接口。

显然，为了实现信号量的功能，我们至少需要提供以下的系统调用接口：

+ init，用于创建一个新信号量；
+ destroy，用于销毁一个信号量；
+ up，用于增加一个信号量，并唤醒因此而被唤醒的进程；
+ down，用于减小一个信号量，当其值为0无法获得时则阻塞当前进程；
+ trydown，用于试着进行down操作，但不阻塞而是返回失败信息。

底层的信号量实现不需要太大变化，把系统调用功能翻译成对信号量处理的代码即可，但是需要加上权限控制：进程试图操作一个信号量时，需要确认该用户程序是否有访问这个信号量的权限。具体而言，信号量应该只允许创建它的进程的子进程访问。


### 练习二/条件变量与管程

#### 机制阐述

管程是一种一般比信号量更高层的进程管理方案。其通过条件变量来完成进程间的信号传递。条件变量与管程的定义如下：

```
typedef struct condvar{
    semaphore_t sem;
    int count;
    monitor_t * owner;
} condvar_t;

typedef struct monitor{
    semaphore_t mutex;
    semaphore_t next;
    int next_count;
    condvar_t *cv;
} monitor_t;

```

管程包括的变量及其作用为：
+ mutex：用于控制管程临界区的互斥锁
+ next：用于激活管程中等待进程的信号量
+ next_count：用于记录管程中等待着条件变量的进程数
+ cv：管程中条件变量列表

其中，条件变量结构中包括的变量及作用为：
+ sem: 用于表示条件变量值的信号量
+ count：表示当前等待这一条件变量的进程数
+ owner：拥有它的管程

当条件变量发出wait操作时，首先将CPU交给管程：若next\_count > 0，表示管程里还有在等待的进程，执行`up(next)`以激活其中之一；否则，将CPU交给管程外的程序，即`up(mutex)`。随后，执行`down(&cvp->sem)`，即在其要等待的条件变量上阻塞，等待其他进程发出信号。其伪代码如下:

```
cv.count ++;
if(mt.next_count>0)
    signal(mt.next)
else
   signal(mt.mutex);
wait(cv.sem);
cv.count --;
```

当对条件变量发出signal操作时，首先判断条件变量是否有进程正阻塞着，若没有，则这个signal没有人正在监听，所以什么都不需做；若有，首先执行`up(&cvp->sem)`，即激活正监听着条件变量的其他一个进程；之后`down(next)`，也即将自己加入管程中的等待队列（或直接执行、让其他同样执行`down(next)`的进程等待）。这是因为其实当前队列并没有在等待任何资源，只是因为管程中同时只能执行一个进程，所以需要暂时阻塞着。不过，等到被调度的进程退出临界区时，便会再次进行`up(next)`，把cpu交还给当前进程。其伪代码如下：

```
if(cv.count>0) {
    mt.next_count ++;
    signal(cv.sem);
    wait(mt.next);
    mt.next_count--;
}
```

综上，就是条件变量的基本操作。

#### 哲学家用餐的实现

接下来就是用条件变量实现哲学家用餐问题。

其思想基本和用信号量实现差不多，只是原本取叉子失败阻塞自己、等待邻居用餐完毕激活自己的这一操作，以前由down和up进行，而现在则由条件变量中的wait和signal完成。代码如下：

```
void phi_take_forks_condvar(int i) {
     down(&(mtp->mutex));
//--------into routine in monitor--------------
     state_condvar[i] = HUNGRY; // I am hungry
     phi_test_condvar(i); // try to get fork
     if (state_condvar[i] != EATING) {
         cprintf("phi_take_forks_condvar: %d didn’t get fork and will wait\n", i);
         cond_wait(&mtp->cv[i]);
     }
//--------leave routine in monitor--------------
      if(mtp->next_count>0)
         up(&(mtp->next));
      else
         up(&(mtp->mutex));
}

void phi_put_forks_condvar(int i) {
     down(&(mtp->mutex));

//--------into routine in monitor--------------
     state_condvar[i] = THINKING; // I ate over
     phi_test_condvar(LEFT);
     phi_test_condvar(RIGHT);
     // test left and right neighbors
//--------leave routine in monitor--------------
     if(mtp->next_count>0)
        up(&(mtp->next));
     else
        up(&(mtp->mutex));
}
```

#### 问题回答

+ 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

对用户态条件变量机制的实现，需要实现以下系统调用（即管程原语）：

+ create，创建管程，接受参数确定生成条件变量个数。
+ wait，接受一个参数——条件变量，将当前进程对该变量进行等待。
+ signal，接受一个参数——条件变量，对该变量发出信号。
+ check，相当于代码中的`down(&(mtp->mutex));`，用于试图进入管程；
+ release，相当于代码中`leave routine in monitor`之后的一段，用于执行管程中的下一个进程或退出管程。
+ remove，销毁管程。

这样一来，对用户端没有暴露信号量的接口，用户也不需要自己执行任何直接管理信号量的操作，只需要调用这些原语即可。

和内核级显然有所差异，首先需要通过系统调用来进行操作，其次由于需要使用系统调用，需要覆盖所有和信号量有关的操作，让用户只接触到管程的原语；此外，应该还需要额外记录管程所对应的进程，防止权限问题。

+ 能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。

应当是可以的。我们这里最后暴露给用户的接口实际上只有管程的几个原语而已，信号量只是内部用于实现条件变量的机制。

设计如下：我们不用信号量来实现条件变量，而是直接用一系列等待队列来完成。实际上就是把信号量需要实现的功能拆出来，写在管程内部。这样做其实本质上和用信号量实现差不多，但是并不需要直接实现信号量。

+ create中，为每个条件变量生成一个等待队列，并为管程生成一个“总等待队列”（相当于原本挂在next条件量下的等待队列），一个“进入管程队列”（相当于原本挂在mutex条件量下的等待队列）；
+ wait中，告知管程可以开始调度下一个进程（唤醒总等待队列下的第一个进程，或置管程于退出状态），将当前进程加入条件变量的等待队列；
+ signal中，去查找条件变量对应的等待队列，唤醒之，自己挂入总等待队列下。
+ check中，若管程已处于进入状态，将进程挂入“进入管程队列”中进入等待状态，否则标记管程为进入状态；
+ release中，若“进入管程队列”非空，取其第一个进程激活；否则标记管程处于退出状态。

综上，需要格外注意的是涉及到等待队列的操作都需要注意关闭中断。这样就只使用等待队列完成了条件变量的功能。

### 对答案

和答案对比，这次实验似乎完全没有差别，毕竟要实现的功能已经在注释里有伪代码详细说明了……

### 知识点分析

这次的知识点包括：

+ 进程的同步互斥机制
+ 几种常见的互斥机制：信号量、管程和条件变量

不过限于ucore规模，覆盖到的知识点有限，例如没有使用原子操作，只能用关中断的方式来模拟原子操作；另外用来解决的问题也只有哲学家用餐这一个作为范例，并不全面。





